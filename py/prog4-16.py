# -*- coding: utf-8 -*-
"""prog4-16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nj6IoE6HpULz7hwczNaKCM6eZAR06w5O
"""

from google.colab import files
files.upload() # kaggle.jsonをアップロード
!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle/
!chmod 600 /root/.kaggle/kaggle.json

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from sklearn.svm import SVC
from sklearn.metrics import classification_report
from sklearn.preprocessing import MinMaxScaler
from sklearn.impute import KNNImputer
import tensorflow.keras as keras
from keras.layers import Input, Dense
from keras.models import Model
from keras.optimizers import Adam
# 可視化用にインポート
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
# UMAPのライブラリをインポート
import umap
def prepare():
    !kaggle datasets download -d \
    uciml/human-activity-recognition-with-smartphones
    !unzip human-activity-recognition-with-smartphones.zip
# 前処理
def preprocess():
    lbh={'WALKING':0, 'WALKING_UPSTAIRS':1, 
          'WALKING_DOWNSTAIRS':2, 'SITTING':3, 
          'STANDING':4, 'LAYING':5}
    trainX, trainY = [], []
    testX, testY = [], []
    for nm in ['train', 'test']:
        df = pd.read_csv('%s.csv' % nm)
        print(df)
        df['Activity'] = df['Activity'].map( lbh )
        df=df.dropna()
        features = []
        for f in df.columns.values:
            if not f in ['subject', 'Activity']:
                features.append(f)
        X = df.loc[:, features].values
        y = df.loc[:, ['Activity']].values.ravel()
        if nm == 'train':
            trainX = X
            trainY = y
        else:
            testX = X
            testY = y
    # 正規化
    sc = MinMaxScaler()
    trainX = sc.fit_transform(trainX)
    testX = sc.transform(testX)
    imp = KNNImputer(n_neighbors=6)
    trainX = imp.fit_transform( trainX )
    testX = imp.transform( testX )
    return trainX, trainY, testX, testY, features

# 自己符号化器の作成
# input_dim: 入力次元数, encoding_dim: 次元削減後の次元数
def make_autoencoder(input_dim, encoding_dim):
    input_data = Input(shape=(input_dim,))
    encoded = Dense(encoding_dim,
                    activation='relu')(input_data)
    decoded = Dense(input_dim, activation='sigmoid')(encoded)
    autoencoder = Model(input_data, decoded)
    # エンコーダ部分のモデル
    encoder = Model(input_data, encoded)
    # デコーダ部分のモデル
    encoded_input = Input(shape=(encoding_dim,))
    decoder_layer = autoencoder.layers[-1]
    decoder = Model(encoded_input,
                    decoder_layer(encoded_input))
    # 最適化手法にAdamを用いる
    adam = Adam(lr=0.001)
    autoencoder.compile(optimizer=adam, loss='mse')
    autoencoder.summary()
    get_encoder_layer_output = \
                Model(inputs=[autoencoder.layers[0].input],
                      outputs=[autoencoder.layers[1].output])    
    return autoencoder, get_encoder_layer_output

# UMAPによる次元削減と可視化
def graph_UMAP( hidden_features, labels, encoding_dim):
    print('\n-----UMAP-----')
    # n_components次元に次元削減
    embedding = umap.UMAP(
    n_components=2).fit_transform(
                          hidden_features)
    ndf = pd.DataFrame(embedding, columns=['1', '2'])
    print(ndf.head())
    plt.figure(figsize=(8,8))
    cols=['red', 'green', 'blue', 'purple', 'black', 'orange']
    markers=['o', 'x', '^', '*', 's', '+']
    lbs = ['WALKING', 'WALKING_UPSTAIRS',
          'WALKING_DOWNSTAIRS','SITTING','STANDING', 'LAYING']
    lbc = [0] * len(lbs)
    for (dim1, dim2, label) in zip(
                   embedding[:,0], embedding[:,1], labels):
        if lbc[int(label)] == 0:
            plt.plot(dim1,dim2, color=cols[int(label)],
                alpha=0.3, marker=markers[int(label)], 
                label=lbs[int(label)])
        else:
            plt.plot(dim1,dim2, color=cols[int(label)],
                marker=markers[int(label)], alpha=0.3)
        lbc[int(label)] += 1
    plt.grid()
    plt.xlabel("DIM-1")
    plt.ylabel("DIM-2")
    plt.legend(loc='lower left')
    plt.savefig('AE-umap-{}.png'.format(encoding_dim))
    plt.show()
    return lbs

# グラフで精度を表示
def makeResultGraph(encoding_dims, accuracies):
    sns.set()
    sns.set_style('whitegrid')
    sns.set_palette('dark')
    x = np.array(encoding_dims)
    y = np.array(accuracies)
    x_position = np.arange(len(x))
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)
    ax.bar(x_position, y, tick_label=x)
    ax.set_xlabel('encoding dim.')
    ax.set_ylabel('Accuracy(%)')
    fig.savefig('AE-SVM-result.png', dpi=400)
    fig.show()

def main():
    prepare()
    x_train, y_train, x_test, y_test, features = preprocess()
    input_dim = len(features)
    accuracies = []
    encoding_dims = [512, 256, 128, 64, 32, 16, 8, 4]
    for encoding_dim in encoding_dims:
        autoencoder, get_encoder_layer_output = \
              make_autoencoder(input_dim, encoding_dim)
        x_train = x_train.reshape(\
              (len(x_train), np.prod(x_train.shape[1:])))
        x_test = x_test.reshape(\
              (len(x_test), np.prod(x_test.shape[1:])))
        # 学習の実行(epoch数は300, バッチサイズは512)
        history = autoencoder.fit(x_train, x_train,
                                epochs=300,
                                batch_size=512,
                                shuffle=True,
                       verbose=0,validation_split=0.2)
        # 中間層の出力をテストデータに対して得る
        layer_output = get_encoder_layer_output(x_test)
        print('Dim. %d' %len(layer_output[0]))
        print(layer_output)                 
        # UMAPで encoding_dim -> 2次元に変換
        lbs = graph_UMAP(layer_output, y_test, encoding_dim)
        # SVMで分類
        print('SVMで分類器を学習・評価')
        # 学習データも自己符号化器により次元削減する
        train_output = get_encoder_layer_output(x_train)
        svm = SVC()
        svm.fit(train_output, y_train)
        y_pred = svm.predict(layer_output)
        clr = classification_report(
            y_test, y_pred, 
            target_names=lbs, output_dict=True)
        accuracies.append(clr['accuracy'] * 100)
    # 各次元の精度(Accuracy)をグラフで示す
    makeResultGraph(encoding_dims, accuracies)

if __name__ == '__main__':
    main()